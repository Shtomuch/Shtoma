---
title: Лабораторна робота №7
outline: deep
---

# Лабораторна робота №7

## Мета роботи:
- Ознайомитися з особливостями багатовимірних масивів;
- Опанувати технологію застосування масивів даних;
- Навчитися розробляти алгоритми та програми із застосуванням багатовимірних масивів

## Умова задачі

### Завдання 1 (Варіант 7)

В кінотеатрі n рядів по m місць в кожному. Значення n та m увести з клавіатури. У двовимірному масиві розмірності n*m зберігається інформація про продані квитки: число 1 означає, що квиток на дане місце вже проданий, число 0 означає, що місце вільне. Передбачити заповнення матриці значеннями 0 та 1 введенням з клавіатури або генерацією випадковими числами. Надійшов запит на продаж k квитків на сусідні місця в одному ряду. Визначити, чи можна виконати такий запит? Якщо k вільних місць в одному ряду, що розташовані поспіль, відсутні, то перевірити, чи можливо "продати" k квитків у двох сусідніх рядах. Вивести на екран матрицю зайнятих та вільних місць у вигляді таблиці з нулів та одиниць, відповідь про можливість виконання першого або другого запиту на продаж k квитків.

### Завдання 2  (Варіант 7)

Визначити ранг матриці, вимірність n>=3 якої ввести з клавіатури. Передбачити меню вибору способу створення матриці: введення з клавіатури або генерація псевдовипадкових додатніх та від'ємних чисел в заданому з клавіатури діапазоні. Рангом матриці називають найбільший порядок її мінорів, відмінних від нуля. Для визначення рангу матриці використати елементарні перетворення матриці, які зводять матрицю до верхньої трикутної, в якій нижче головної діагоналі всі елементи дорівнюють нулю. Тоді ранг матриці дорівнює кількості елементів головної діагоналі, відмінних від нуля. Перевірити, що ранг матриці дорівнює максимальній кількості лінійно незалежних рядків (стовпців) матриці. Вивести на екран вхідну матрицю, верхню трикутну матрицю, її ранг та максимальну кількість лінійно незалежних рядків (стовпців) матриці. Передбачити можливість виведення проміжних результатів елементарних перетворень вхідної матриці.

## Аналіз задачі

Обидва завдання вимагають отримання чисел з консолі. Для цього можна використовувати функції, які надає стандартна бібліотека C++. 

###  Завдання 1 (Варіант 7)

 Отримання даних з консолі:
1. **Введення розмірів кінотеатру**:
   - Користувач вводить кількість рядів \( n \) та кількість місць в ряду \( m \).
2. **Вибір способу заповнення матриці**:
   - Користувач обирає спосіб заповнення матриці: вручну або генерацією псевдовипадкових чисел.
3. **Введення або генерація матриці**:
   - Якщо вибрано введення вручну, користувач вводить значення для кожного елемента матриці (0 або 1).
   - У випадку генерації, матриця заповнюється випадковими числами 0 або 1.
4. **Введення кількості квитків для запиту**:
   - Користувач вводить кількість квитків \( k \), які потрібно продати.

 Обробка даних:
1. **Пошук вільних місць**:
   - Програма шукає \( k \) вільних місць, що йдуть підряд, в одному ряду.
   - Якщо такі місця знайдені, фіксується можливість продажу в одному ряду.
   - Якщо ні, перевіряється можливість продажу \( k \) квитків у двох сусідніх рядах.

 Виведення результатів:
1. **Візуалізація місць у кінотеатрі**:
   - Виведення матриці зайнятих та вільних місць.
2. **Відповідь на запит**:
   - Виведення відповіді на запит про можливість продажу \( k \) квитків в одному або двох рядах.

###  Завдання 2 (Варіант 7)

 Отримання даних з консолі:
1. **Введення розміру матриці**:
   - Користувач вводить розмірність матриці \( n \geq 3 \).
2. **Вибір способу заповнення матриці**:
   - Користувач обирає спосіб заповнення: вручну або генерація псевдовипадкових чисел.
3. **Введення або генерація матриці**:
   - Якщо вибрано введення вручну, користувач вводить значення для кожного елемента матриці.
   - У випадку генерації, матриця заповнюється випадковими числами в заданому діапазоні.

 Обробка даних:
1. **Перетворення матриці до верхньої трикутної форми**:
   - Використання елементарних перетворень для переведення матриці у верхню трикутну форму.
2. **Визначення рангу матриці**:
   - Ранг матриці дорівнює кількості ненульових елементів на головній діагоналі отриманої верхньої трикутної матриці.

  Виведення результатів:
1. **Виведення матриць**:
   - Виведення початкової матриці.
   - Виведення верхньої трикутної матриці.
2. **Виведення рангу та інформації про лінійну незалежність**:
   - Виведення рангу матриці.
   - Виведення максимальної кількості лінійно незалежних рядків (стовпців) матриці.
3. **Опційно, виведення проміжних результатів**:
   - Можливість вивести етапи елементарних перетворень матриці.


## Блок-схема програми 1 та 2
### Завдання 1
![Схема](https://i.imgur.com/OInFBUk.png)
![Схема](https://i.imgur.com/iCXv94t.png)
### Завдання 2
![Схема](https://i.imgur.com/K7eifFp.png)
![Схема](https://i.imgur.com/8SWXDxx.png)


## Код програм
### Завдання 1

```cpp
#include <iostream>
#include <ctime>
#include <string>
#include <limits>
#include <windows.h>


using namespace std;

const int MAX_N = 100;
const int MAX_M = 100;


// Функція для заповнення матриці з клавіатури
void fillMatrixFromKeyboard(int matrix[MAX_N][MAX_M], int n, int m) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cin >> matrix[i][j];
        }
    }
}

// Функція для заповнення матриці псевдовипадковими числами
void fillMatrixRandomly(int matrix[MAX_N][MAX_M], int n, int m) {
    srand(time(NULL));
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            matrix[i][j] = rand() % 2;
        }
    }
}

// Функція для перевірки можливості розміщення k сусідніх місць в одному ряду
bool checkRow(int row[MAX_M], int m, int k) {
    int count = 0;
    for (int i = 0; i < m; i++) {
        if (row[i] == 0) {
            count++;
            if (count == k) {
                return true;
            }
        }
        else {
            count = 0;
        }
    }
    return false;
}

// Функція для перевірки можливості розміщення k місць у двох сусідніх рядах
bool checkAdjacentRows(int matrix[MAX_N][MAX_M], int n, int m, int k) {
    for (int i = 0; i < n - 1; i++) { // Проходимо по всім рядам, крім останнього
        int freeSeatsFirstRow = 0; // Вільні місця в першому ряду
        int freeSeatsSecondRow = 0; // Вільні місця в другому ряду

        // Рахуємо вільні місця в першому ряду
        for (int j = 0; j < m; j++) {
            if (matrix[i][j] == 0) {
                freeSeatsFirstRow++;
            }
        }

        // Рахуємо вільні місця в другому ряду
        for (int j = 0; j < m; j++) {
            if (matrix[i + 1][j] == 0) {
                freeSeatsSecondRow++;
            }
        }

        // Якщо сума вільних місць у двох рядах більша або дорівнює k, повертаємо true
        if (freeSeatsFirstRow + freeSeatsSecondRow >= k) {
            return true;
        }
    }
    return false; // Не знайдено достатньо вільних місць
}

int inputIntWithCheck(const string& prompt, int minValue, int maxValue) {
    int value;
    do {
        cout << prompt;
        cin >> value;
        if (cin.fail() || value < minValue || value > maxValue) {
            cout << "Введене значення некоректне. Будь ласка, спробуйте знову." << endl;
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        }
        else {
            break;
        }
    } while (true);
    return value;
}

int main() {
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    int n, m, k;
    int matrix[MAX_N][MAX_M];

    n = inputIntWithCheck("Введіть кількість рядів n (1-" + to_string(MAX_N) + "): ", 1, MAX_N);
    m = inputIntWithCheck("Введіть кількість місць в ряду m (1-" + to_string(MAX_M) + "): ", 1, MAX_M);

    int choice = inputIntWithCheck("Оберіть спосіб заповнення матриці (1 - з клавіатури, 2 - псевдовипадковими числами): ", 1, 2);
    if (choice == 1) {
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < m; j++) {
                matrix[i][j] = inputIntWithCheck("Введіть значення для matrix[" + to_string(i) + "][" + to_string(j) + "] (0 або 1): ", 0, 1);
            }
        }
    }
    else {
        fillMatrixRandomly(matrix, n, m);
    }

    k = inputIntWithCheck("Введіть кількість бажаних місць k (1-" + to_string(n * m) + "): ", 1, n * m);

    bool canAllocateInSingleRow = false;
    bool canAllocateInAdjacentRows = false;

    for (int i = 0; i < n && !canAllocateInSingleRow; i++) {
        if (checkRow(matrix[i], m, k)) {
            canAllocateInSingleRow = true;
        }
    }

    if (!canAllocateInSingleRow) {
        canAllocateInAdjacentRows = checkAdjacentRows(matrix, n, m, k);
    }

    cout << "Матриця зайнятих та вільних місць:\n";
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < m; j++) {
            cout << matrix[i][j] << " ";
        }
        cout << endl;
    }

    if (canAllocateInSingleRow) {
        cout << "Можна розмістити " << k << " сусідніх місць у одному ряду." << endl;
    }
    else if (canAllocateInAdjacentRows) {
        cout << "Можна розмістити " << k << " сусідніх місць, але лише у двох сусідніх рядах." << endl;
    }
    else {
        cout << "Не можна розмістити " << k << " сусідніх місць." << endl;
    }

    return 0;
}

```

### Завдання 2

```cpp
#include <iostream>
#include <iomanip>
#include <string>
#include <limits>
#include <random>
#include <windows.h>
using namespace std;

const int MAX_N = 100;
const float EPSILON = 1e-5; // Значення, нижче якого числа вважаються "достатньо близькими" до нуля


int inputIntWithCheck(const string& prompt, int minValue, int maxValue) {
    int value;
    while (true) {
        cout << prompt;
        if (!(cin >> value) || value < minValue || value > maxValue) {
            cout << "Введене значення некоректне або виходить за межі допустимого діапазону. Будь ласка, спробуйте знову." << endl;
            cin.clear();
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
        } else {
            cin.ignore(numeric_limits<streamsize>::max(), '\n');
            break;
        }
    }
    return value;
}

void printMatrix(float matrix[MAX_N][MAX_N], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            cout << setw(10) << matrix[i][j];
        }
        cout << endl;
    }
}

void fillMatrixFromKeyboard(float matrix[MAX_N][MAX_N], int n) {
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            // Використовуємо inputIntWithCheck для отримання цілочисельного вводу
            int value = inputIntWithCheck("Введіть елемент [" + to_string(i) + "][" + to_string(j) + "]: ", INT_MIN, INT_MAX);
            matrix[i][j] = value;
        }
    }
}


void fillMatrixRandomly(float matrix[MAX_N][MAX_N], int n, int minValue, int maxValue) {
    random_device rd;
    mt19937 gen(rd());
    uniform_int_distribution<> dis(minValue, maxValue);
    for (int i = 0; i < n; i++) {
        for (int j = 0; j < n; j++) {
            matrix[i][j] = dis(gen);
        }
    }
}

// Функція для визначення рангу матриці з використанням методу Гауса
int rankOfMatrix(float matrix[MAX_N][MAX_N], int n, bool showSteps) {
    int rank = 0; // Лічильник для рангу матриці
    bool changed; // Прапорець для перевірки, чи відбулися зміни в матриці

    // Головний цикл по рядках матриці
    for (int i = 0; i < n; i++) {
        changed = false; // Скидаємо прапорець зміни на початку кожного циклу

        // Якщо елемент на діагоналі дорівнює нулю, шукаємо ненульовий елемент в тому ж стовпці
        if (matrix[i][i] == 0) {
            for (int j = i + 1; j < n; j++) {
                if (matrix[j][i] != 0) {
                    // Міняємо рядки місцями
                    for (int k = 0; k < n; k++) {
                        // Перед тим, як почати цикл по k
                        float temp; // Тимчасова змінна для обміну значень
                        for (int h = 0; h < n; h++) {
                            temp = matrix[i][h]; // Зберігаємо значення з першого рядка у тимчасовій змінній
                            matrix[i][h] = matrix[j][h]; // Присвоюємо першому рядку значення з другого рядка
                            matrix[j][h] = temp; // Присвоюємо другому рядку збережене значення з тимчасової змінної
                        }

                    }
                    changed = true; // Відзначаємо, що сталася зміна
                    break; // Виходимо з внутрішнього циклу
                }
            }
        }

        // Якщо елемент на діагоналі тепер не нуль, збільшуємо ранг
        if (matrix[i][i] != 0) {
            rank++;
            // Виконуємо елементарні перетворення над нижчими рядками, щоб створити нулі під діагоналлю
            for (int j = i + 1; j < n; j++) {
                float factor = matrix[j][i] / matrix[i][i];
                for (int k = i; k < n; k++) {
                    matrix[j][k] -= factor * matrix[i][k];
                    // Якщо елемент близький до нуля, вважаємо його нулем
                    if (abs(matrix[j][k]) < EPSILON) {
                        matrix[j][k] = 0;
                    }
                }
                changed = true; // Відзначаємо, що сталася зміна
            }
        }

        // Якщо були зміни і потрібно вивести проміжні кроки, виводимо матрицю
        if (showSteps && changed) {
            cout << "Крок " << i + 1 << ":\n";
            printMatrix(matrix, n); // Виводимо поточний стан матриці
            cout << "----------------------\n"; // Роздільник для кращої видимості
        }

        // Якщо змін не було, значить всі рядки нижче містять нулі і можна завершити роботу
        if (!changed) break;
    }

    return rank; // Повертаємо ранг матриці
}


int main() {
    SetConsoleOutputCP(CP_UTF8);
    SetConsoleCP(CP_UTF8);

    int n = inputIntWithCheck("Введіть розмірність матриці n (3-" + to_string(MAX_N) + "): ", 3, MAX_N);

    float matrix[MAX_N][MAX_N];
    int choice = inputIntWithCheck("Оберіть спосіб заповнення матриці (1 - з клавіатури, 2 - псевдовипадковими числами): ", 1, 2);

    if (choice == 1) {
        fillMatrixFromKeyboard(matrix, n);
    } else {
        int maxValue = inputIntWithCheck("Введіть максимальний модуль числа для елементів матриці (1-100): ", 1, 100);
        fillMatrixRandomly(matrix, n, -maxValue, maxValue);
    }

    bool showSteps = inputIntWithCheck("Вивести проміжні результати? (1 - так, 2 - ні): ", 1, 2) == 1;

    cout << "\nВхідна матриця:\n";
    printMatrix(matrix, n);
    cout << "----------------------\n";

    int matrixRank = rankOfMatrix(matrix, n, showSteps);

    cout << "Верхньо-трикутна матриця:\n";
    printMatrix(matrix, n);
    cout << "----------------------\n";

    cout << "Ранг матриці: " << matrixRank << endl;
    cout << "Максимальна кількість лінійно незалежних рядків (стовпців) матриці: " << matrixRank << endl;

    return 0;
}
```


## Результат виконання програм
### Завдання 1

![Результат](https://i.imgur.com/iOmCcsW.png)

### Завдання 2

![Результат](https://i.imgur.com/bRK0uK9.png)

## Аналіз достовірності результатів

Під час виконання програма виводить числа в консоль з обмеженням
кількості цифр за замовчуванням.

### Завдання 1

![Результат](https://i.imgur.com/bJ1GTOO.png)

### Завдання 2:

Як ми бачимо програма вірно визначила ранг матриці.

![Результат](https://i.imgur.com/bRK0uK9.png)
![Результат](https://i.imgur.com/1GuKWGN.png)


## Висновки
Після виконання цієї лабораторної роботи я отримав значно глибше розуміння багатовимірних масивів та їх застосування у програмуванні. Робота над розробкою алгоритмів для визначення вільних місць у кінотеатрі та обчислення рангу матриці значно поглибила мої знання та практичні навички. Ця робота дозволила мені краще зрозуміти, як ефективно обирати підходи для конкретних задач, особливо у контексті обробки даних та вирішення алгоритмічних проблем. Важливим аспектом також стала коректна обробка даних, введених користувачем, та розуміння потенційних помилок при вводі даних. Загалом, ця робота виявилася надзвичайно корисною для розвитку моїх програмістських навичок, надавши мені цінний досвід у реалізації та аналізі складних програмних задач.







