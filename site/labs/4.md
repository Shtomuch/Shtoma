---
title: Лабораторна робота №4
outline: deep
---

# Лабораторна робота №4

## Мета

- Вивчити особливості циклічних обчислювальних процесів з розгалуженнями
- Опанувати технологію рекурентних обчислень
- Навчитися розробляти алгоритми та програми розвинення функцій у ряди

## Умова задачі

### Завдання 1 (Варіант 7)

Визначити значення функції в залежності від значення її аргументу, яке вводиться з клавіатури.

### Завдання 2  (Варіант 7)

Обчислити ланцюгові дроби, степеневі ряди, розв'язати комбінаторні задачі відповідно до варіантів, поданих в таблиці 4.3.

## Аналіз задачі

Обидва завдання вимагають отримання чисел з консолі. Для цього можна використовувати функції, які надає стандартна бібліотека C++. 

### Завдання 1

Задача полягає в тому, щоб обчислити значення функції, розвинувши її у ряд Тейлора. Параметр функції має змінюватися від заданого користувачем мінімального значення до максимального значення із певним кроком. 

Основні кроки для виконання задачі:

1. **Отримання даних з консолі**: Користувач вводить мінімальне та максимальне значення параметра, крок та точність розрахунку. Програма повинна перевірити коректність введених даних.

2. **Обчислення за заданою функцією**: Функція розвивається у ряд Тейлора з заданою користувачем точністю. Для розвинення функції в ряд використовується власна функція зі спрощеною формулою : ![Схема](https://i.imgur.com/SvaK7ap.png) , яка розраховує суму ряду за рекурентним співвідношенням.

3. **Виведення результату на консоль**: Після завершення обчислень програма виводить таблицю результатів, яка містить значення аргумента, значення функції, стандартне значення функції та похибку.

### Завдання 2

Задача полягає в обчисленні нескінченного ланцюгового дробу, задавши кількість дробів з клавіатури.

Основні кроки для виконання задачі:

1. **Отримання кількості дробів**: Користувач вводить кількість дробів, яку він хоче використовувати для обчислення ланцюгового дробу. Програма перевіряє коректність введених даних.

2. **Обчислення ланцюгового дробу**: Використовуючи рекурсивний підхід, програма обчислює значення ланцюгового дробу на основі введеної кількості дробів.

3. **Виведення результату на консоль**: Після завершення обчислень програма виводить результат ланцюгового дробу на консоль.

4. **Обробка помилок**: Цей аспект важливий на кожному кроці програми. Помилки можуть виникати через некоректний ввод даних користувачем. Кожен раз, коли виникає помилка, програма повідомляє користувача про неї і просить ввести дані знову..

## Блок-схема програми 1 та 2
### Завдання 1
![Схема](https://i.imgur.com/QarzV0i.png)
![Схема](https://i.imgur.com/9O8xluj.png)
### Завдання 2
![Схема](https://i.imgur.com/NFwDRkm.png)
## Код програм
### Завдання 1

```cpp

#include <iostream>
#include <cmath>
#include <iomanip>
#include <limits>

double sinTaylor(double x, double precision) {
    double term = x;
    double sum = term;
    int n = 1;
    while (fabs(term) > precision) {
        term *= -x * x / ((2 * n) * (2 * n + 1));
        sum += term;
        n++;
    }
    return sum;
}

bool isValidInput() {
    if (std::cin.fail()) {
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        std::cout << "Invalid input! Please enter a valid number." << std::endl;
        return false;
    }
    return true;
}

int main() {
    double xMin, xMax, step, precision;

    do {
        std::cout << "Enter minimum value of x: ";
        std::cin >> xMin;
    } while (!isValidInput());

    do {
        std::cout << "Enter maximum value of x: ";
        std::cin >> xMax;
    } while (!isValidInput());

    if (xMax < xMin) {
        std::cout << "Error: Maximum value of x should be greater than the minimum value." << std::endl;
        return 1;
    }

    do {
        std::cout << "Enter step: ";
        std::cin >> step;
        if (step <= 0) {
            std::cout << "Step cannot be zero or negative. Please enter a valid step value." << std::endl;
        }
    } while (!isValidInput() || step <= 0);

    do {
        std::cout << "Enter precision (from 10^-2 to 10^-6): ";
        std::cin >> precision;
        if (precision < 1e-6 || precision > 1e-2) {
            std::cout << "Invalid precision. Please enter a value between 10^-2 and 10^-6." << std::endl;
        }
    } while (!isValidInput() || precision < 1e-6 || precision > 1e-2);

    std::cout << std::fixed << std::setprecision(6);
    std::cout << "x\t\ty\t\tStandard y\tError\n";
    for (double x = xMin; x <= xMax; x += step) {
        double y;
        if (x > 0 && x < 1) {
            y = sinTaylor(x, precision) - sinTaylor(x / 2, precision);
        }
        else if (x >= -2 && x <= 0) {
            y = pow(sinTaylor(x, precision), 3) - sinTaylor(x + 0.125, precision);
        }
        else {
            std::cout << x << "\tfunction is not defined\n";
            continue;
        }

        double yStandard;
        if (x > 0 && x < 1) {
            yStandard = sin(x) - sin(x / 2);
        }
        else {
            yStandard = pow(sin(x), 3) - sin(x + 0.125);
        }

        double error = fabs(y - yStandard);
        std::cout << x << "\t" << y << "\t" << yStandard << "\t" << error << "\n";
    }

    return 0;
}


```

### Завдання 2

```cpp
#include <iostream>
#include <limits>

double chainFraction(int n) {
    if (n == 1) {
        return 4.0;
    }
    return 4.0 + 1.0 / chainFraction(n - 1);
}

bool isValidInput() {
    if (std::cin.fail() || std::cin.peek() != '\n') {
        std::cin.clear();
        std::cin.ignore(std::numeric_limits<std::streamsize>::max(), '\n');
        std::cout << "Invalid input! Please enter a valid number." << std::endl;
        return false;
    }
    return true;
}

int main() {
    int numFractions;

    do {
        std::cout << "Enter the number of fractions (positive integer): ";
        std::cin >> numFractions;

        if (numFractions <= 0) {
            std::cout << "Number of fractions cannot be zero or negative. Please enter a positive integer." << std::endl;
        }
    } while (!isValidInput() || numFractions <= 0);

    double result = 2.0 + 1.0 / chainFraction(numFractions);
    std::cout << "The value of the chain fraction for " << numFractions << " fractions is: " << result << std::endl;

    return 0;
}


```
## Результат виконання програм
### Завдання 1

![Результат](https://i.imgur.com/M7FjaQN.png)

### Завдання 2

![Результат](https://i.imgur.com/3vb0uPE.png)
![Результат](https://i.imgur.com/VGyFRaJ.png)

## Аналіз достовірності результатів

Під час виконання програма виводить числа в консоль з обмеженням
кількості цифр за замовчуванням.

### Завдання 1: Розкладання в ряд Тейлора для синуса

Тестування програми для значень \(X = -1\) та \(X = 2\).

1. **Вхідні дані**:
   - \(xMin = -1\)
   - \(xMax = 2\)
   - \(step = 1\) (для спрощення)
   - \(precision = 0.001\) (або інше значення, яке ви оберете)

2. **Початок програми**:
   - Програма просить ввести мінімальне значення \(x\). Ми вводимо -1.
   - Програма перевіряє чи введене значення є коректним. У нашому випадку - так.
   - Програма просить ввести максимальне значення \(x\). Ми вводимо 2.
   - Програма перевіряє чи введене значення є коректним. У нашому випадку - так.
   - Програма перевіряє чи \(xMax > xMin\). У нашому випадку - так.
   - Програма просить ввести крок. Ми вводимо 1.
   - Програма перевіряє чи введене значення є коректним та чи крок більший за 0. У нашому випадку - так.
   - Програма просить ввести точність. Ми вводимо 0.001.
   - Програма перевіряє чи введене значення є коректним та чи точність знаходиться в діапазоні від \(10^{-6}\) до \(10^{-2}\). У нашому випадку - так.

3. **Обчислення та виведення результатів**:
   - Програма виводить заголовки таблиці: \(x\), \(y\), \(Standard y\), \(Error\).
   - Для \(x = -1\):
     - Оскільки \(x >= -2\) та \(x <= 0\), то \(y = pow(sinTaylor(x, precision), 3) - sinTaylor(x + 0.125, precision)\).
     - Обчислюємо стандартне значення \(y\) за допомогою вбудованої функції sin: \(yStandard = pow(sin(x), 3) - sin(x + 0.125)\).
     - Обчислюємо похибку: \(error = fabs(y - yStandard)\).
     - Виводимо результати для \(x = -1\).
   - Для \(x = 2\):
     - Оскільки жодна з умов не виконується, програма виводить повідомлення, що функція не визначена для \(x = 2\).

**Результат**:
Для \(X = -1\) програма виведе обчислене значення \(y\), стандартне значення \(y\) та похибку. Для \(X = 2\) програма виведе повідомлення, що функція не визначена для цього значення.
![Результат](https://i.imgur.com/ecNl5K6.png)
![Результат](https://i.imgur.com/4RkVA7A.png)

### Завдання 2: Обчислення ланцюгового дробу

1. **Вхідні дані**: 
   - n = 1
   - Очікуваний результат: 2 + 1/4 = 2.25

2. **Вхідні дані**: 
   - n = 2
   - Очікуваний результат: 2 + 1/(4 + 1/4) = 2 + 1/4.25 ≈ 2.2353

3. **Вхідні дані**: 
   - n = 3
   - Очікуваний результат: 2 + 1/(4 + 1/(4 + 1/4)) = 2 + 1/4.2353 ≈ 2.2361

Для кожного тестового випадку, можна ввести відповідні вхідні дані в програму і порівняти результат з очікуваним.

## Висновки

Після виконання цієї роботи я глибше зрозумів важливість детального аналізу завдань перед розробкою програми. Робота над розкладанням функції в ряд Тейлора та обчисленням ланцюгового дробу показала, наскільки важливо враховувати всі можливі варіанти введення даних користувачем та передбачити обробку помилок. Також я наголосив на значущості візуалізації логіки програми за допомогою блок-схем, що спрощує розуміння та аналіз коду. Загалом, ця робота підсилила мої навички в алгоритмізації та програмуванні.




